Hello! As a Lead Frontend Engineer handing off to a Backend Engineer, I will break down exactly how the Super Admin configuration system works.
In essence, the Super Admin dashboard acts as a Content Management System (CMS) for the application's metadata. Instead of hardcoding categories or badge logic in the code, we store them in the database. The frontend fetches this configuration on load to build the UI and logic dynamically.
Here is the complete specification for replicating this on a real backend.
1. Dynamic Categories & Sub-categories
The Super Admin can Create, Read, Update, and Delete (CRUD) categories. This controls what options citizens see in the "Report Wizard" and how reports are filtered on the map.
The Mechanism
Fetch: On app load, the frontend calls GET /api/categories.
Render: The frontend iterates through this list to generate the selection buttons, map pins (colors/icons), and filter dropdowns.
Update: When the Super Admin edits a category (e.g., changes a color or adds a sub-category), they send a PUT request with the full object.
Icons: We store the string name of the icon (e.g., "FaRoad") in the database. The frontend maps this string to the actual React Icon component.
Database Schema (JSON Representation)
You need a table/collection that stores these objects.
code
TypeScript
interface DynamicCategory {
  id: string;           // Primary Key (slug-style, e.g., 'public_safety')
  name_en: string;      // English label
  name_ar: string;      // Arabic label
  icon: string;         // Key from ICON_MAP (e.g., 'FaShieldHalved')
  color_light: string;  // Hex code for Light Mode
  color_dark: string;   // Hex code for Dark Mode
  is_active: boolean;   // Soft delete mechanism. If false, hide from Citizen UI.
  subCategories: {      // Array of sub-options
    id: string;
    name_en: string;
    name_ar: string;
  }[];
}
Default Data (Seed Content)
Here is the exact dataset currently used in the prototype. You should seed your production database with this JSON.
code
JSON
[
  {
    "id": "infrastructure",
    "icon": "FaRoadBridge",
    "color_light": "#4A90E2",
    "color_dark": "#5EBFDE",
    "name_en": "Infrastructure",
    "name_ar": "البنية التحتية",
    "is_active": true,
    "subCategories": [
      { "id": "unpaved_roads", "name_en": "Unpaved or damaged roads", "name_ar": "طرق غير معبدة أو متضررة" },
      { "id": "broken_sidewalks", "name_en": "Broken or occupied sidewalks", "name_ar": "أرصفة مكسورة أو مشغولة" },
      { "id": "bridge_maintenance", "name_en": "Bridges/stairways maintenance", "name_ar": "صيانة الجسور والسلالم" }
    ]
  },
  {
    "id": "electricity_energy",
    "icon": "FaBolt",
    "color_light": "#F5A623",
    "color_dark": "#FFC06A",
    "name_en": "Electricity & Energy",
    "name_ar": "الكهرباء والطاقة",
    "is_active": true,
    "subCategories": [
      { "id": "unprotected_poles", "name_en": "Unprotected electricity poles", "name_ar": "أعمدة كهرباء غير محمية" },
      { "id": "exposed_wires", "name_en": "Exposed electric wires", "name_ar": "أسلاك كهربائية مكشوفة" },
      { "id": "unsafe_generators", "name_en": "Unsafe private generator connections", "name_ar": "وصلات مولدات خاصة غير آمنة" },
      { "id": "public_lighting", "name_en": "Malfunctioning public lighting", "name_ar": "إنارة عامة معطلة" }
    ]
  },
  {
    "id": "water_sanitation",
    "icon": "FaFaucetDrip",
    "color_light": "#50E3C2",
    "color_dark": "#63E9C8",
    "name_en": "Water & Sanitation",
    "name_ar": "المياه والصرف الصحي",
    "is_active": true,
    "subCategories": [
      { "id": "water_leak", "name_en": "Leaking potable water", "name_ar": "تسرب مياه الشرب" },
      { "id": "blocked_sewage", "name_en": "Blocked or overflowing sewage", "name_ar": "مجاري مسدودة أو فائضة" },
      { "id": "stormwater_drainage", "name_en": "Lack of stormwater drainage", "name_ar": "نقص في أنظمة تصريف مياه الأمطار" }
    ]
  },
  {
    "id": "waste_environment",
    "icon": "FaRecycle",
    "color_light": "#B8E986",
    "color_dark": "#C6F497",
    "name_en": "Waste & Environment",
    "name_ar": "النفايات والبيئة",
    "is_active": true,
    "subCategories": [
      { "id": "garbage_accumulation", "name_en": "Garbage accumulation", "name_ar": "تراكم القمامة" },
      { "id": "missing_bins", "name_en": "Missing/overflowing bins", "name_ar": "حاويات مفقودة/فائضة" },
      { "id": "illegal_dumping", "name_en": "Illegal dumping sites", "name_ar": "مكبات نفايات غير شرعية" },
      { "id": "visual_pollution", "name_en": "Visual pollution (ads, etc.)", "name_ar": "تلوث بصري (إعلانات، تشويه)" },
      { "id": "noise_pollution", "name_en": "Noise pollution", "name_ar": "تلوث ضوضائي" }
    ]
  },
  {
    "id": "public_safety",
    "icon": "FaShieldHalved",
    "color_light": "#9013FE",
    "color_dark": "#A53AFF",
    "name_en": "Public Safety",
    "name_ar": "السلامة العامة",
    "is_active": true,
    "subCategories": [
      { "id": "broken_traffic_lights", "name_en": "Broken traffic lights", "name_ar": "إشارات مرور معطلة" },
      { "id": "missing_crossings", "name_en": "Missing pedestrian crossings", "name_ar": "غياب ممرات المشاة" },
      { "id": "unsafe_construction", "name_en": "Unsafe construction", "name_ar": "مواقع بناء غير آمنة" },
      { "id": "abandoned_vehicles", "name_en": "Abandoned/dangerously parked vehicles", "name_ar": "سيارات مهجورة أو متوقفة بشكل خطير" }
    ]
  },
  {
    "id": "public_spaces",
    "icon": "FaTreeCity",
    "color_light": "#417505",
    "color_dark": "#549407",
    "name_en": "Public Spaces",
    "name_ar": "المساحات العامة",
    "is_active": true,
    "subCategories": [
      { "id": "neglected_parks", "name_en": "Neglected or dirty parks", "name_ar": "حدائق مهملة أو متسخة" },
      { "id": "broken_equipment", "name_en": "Broken benches or playground equipment", "name_ar": "مقاعد أو معدات ملاعب مكسورة" },
      { "id": "square_lighting", "name_en": "Non-functioning streetlights in squares", "name_ar": "إنارة معطلة في الساحات العامة" },
      { "id": "damaged_facilities", "name_en": "Damaged public facilities", "name_ar": "مرافق عامة متضررة" }
    ]
  },
  {
    "id": "public_health",
    "icon": "FaBriefcaseMedical",
    "color_light": "#D0021B",
    "color_dark": "#E83D4F",
    "name_en": "Public Health",
    "name_ar": "الصحة العامة",
    "is_active": true,
    "subCategories": [
      { "id": "stray_animals", "name_en": "Stray animals posing risks", "name_ar": "حيوانات شاردة تشكل خطراً" },
      { "id": "insects_rodents", "name_en": "Spread of insects/rodents", "name_ar": "انتشار الحشرات/القوارض" },
      { "id": "stagnant_water", "name_en": "Stagnant or contaminated water", "name_ar": "مياه راكدة أو ملوثة" }
    ]
  },
  {
    "id": "urban_planning",
    "icon": "FaRulerCombined",
    "color_light": "#BD10E0",
    "color_dark": "#D02FFA",
    "name_en": "Urban Planning",
    "name_ar": "التخطيط العمراني",
    "is_active": true,
    "subCategories": [
      { "id": "illegal_construction", "name_en": "Illegal construction", "name_ar": "بناء مخالف" },
      { "id": "occupied_sidewalks", "name_en": "Sidewalks occupied by shops", "name_ar": "أرصفة محتلة من قبل المحلات" },
      { "id": "public_property_encroachment", "name_en": "Encroachment on public property", "name_ar": "تعدي على الأملاك العامة" }
    ]
  },
  {
    "id": "transportation",
    "icon": "FaBus",
    "color_light": "#7ED321",
    "color_dark": "#91E33A",
    "name_en": "Transportation",
    "name_ar": "النقل",
    "is_active": true,
    "subCategories": [
      { "id": "unregulated_stops", "name_en": "Unregulated bus stops", "name_ar": "مواقف حافلات غير منظمة" },
      { "id": "parking_issues", "name_en": "Lack or poor organization of parking", "name_ar": "نقص أو سوء تنظيم مواقف السيارات" },
      { "id": "missing_signage", "name_en": "Missing traffic signage", "name_ar": "غياب اللافتات المرورية" }
    ]
  },
  {
    "id": "emergencies",
    "icon": "FaTriangleExclamation",
    "color_light": "#FF5A5F",
    "color_dark": "#FF8A8D",
    "name_en": "Emergencies",
    "name_ar": "الطوارئ",
    "is_active": true,
    "subCategories": [
      { "id": "accidents_collapses", "name_en": "Accidents or collapses", "name_ar": "حوادث أو انهيارات" },
      { "id": "falling_trees", "name_en": "Trees at risk of falling", "name_ar": "أشجار معرضة للسقوط" },
      { "id": "landslides", "name_en": "Landslides after storms", "name_ar": "انهيارات أرضية بعد العواصف" }
    ]
  },
  {
    "id": "transparency_services",
    "icon": "FaFileSignature",
    "color_light": "#0D3B66",
    "color_dark": "#1E5A99",
    "name_en": "Transparency & Services",
    "name_ar": "الشفافية والخدمات",
    "is_active": true,
    "subCategories": [
      { "id": "absent_employees", "name_en": "Municipal employees absent", "name_ar": "غياب موظفي البلدية" },
      { "id": "paperwork_delays", "name_en": "Delays in citizen paperwork", "name_ar": "تأخير في معاملات المواطنين" },
      { "id": "lack_of_services", "name_en": "Lack of essential municipal services", "name_ar": "نقص في الخدمات البلدية الأساسية" }
    ]
  },
  {
    "id": "other_unknown",
    "icon": "FaQuestion",
    "color_light": "#9E9E9E",
    "color_dark": "#BDBDBD",
    "name_en": "Other / Unknown",
    "name_ar": "أخرى / غير معروف",
    "is_active": true,
    "subCategories": [
      { "id": "unclear_issue", "name_en": "Unclear or out-of-scope issue", "name_ar": "مشكلة غير واضحة أو خارج النطاق" }
    ]
  }
]
2. Gamification: Points Rules
The Super Admin can adjust the number of points awarded for specific user actions.
The Mechanism
The frontend sends the action performed (e.g., submit_report) to the backend.
The backend (or frontend before calling backend) looks up the point value in the GamificationSettings table.
It adds that amount to the user's score.
Database Schema
A simple object or table to store the rules.
code
TypeScript
interface GamificationSettings {
  id: string; // Always 'default' (singleton)
  pointsRules: {
    id: 'submit_report' | 'confirm_report' | 'earn_badge'; // Fixed IDs
    points: number; // Admin can change this
    description: string;
  }[];
}
Default Data (Seed Content)
code
JSON
{
  "id": "default",
  "pointsRules": [
    { "id": "submit_report", "points": 10, "description": "Submit a new report" },
    { "id": "confirm_report", "points": 3, "description": "For confirming an existing report" },
    { "id": "earn_badge", "points": 25, "description": "Bonus for earning a new badge" }
  ]
}
3. Gamification: Badges
Badges are awarded automatically based on logic defined in the criteria field. The Super Admin can create new badges or modify criteria.
The Mechanism
Trigger: Whenever a user performs an action (submits report, confirms), the system checks their stats against the badge list.
Criteria Logic: The backend must implement a "Rules Engine" that reads the criteria JSON and evaluates it.
report_count: Count reports created by user. Optionally filter by category_filter.
confirmation_count: Count confirmations made by user.
point_threshold: Check user's total points.
If User Stat >= Badge Criteria Value AND User doesn't have badge, award badge.
Database Schema (JSON Representation)
code
TypeScript
interface DynamicBadge {
  id: string;
  name_en: string;
  name_ar: string;
  description_en: string;
  description_ar: string;
  icon: string; // Key from ICON_MAP (e.g., 'FaTrophy')
  is_active: boolean;
  criteria: {
    type: 'report_count' | 'confirmation_count' | 'point_threshold';
    value: number;
    category_filter?: string; // Optional: The ID of a Category (e.g., 'infrastructure')
  };
}
Default Data (Seed Content)
Seed this into your badges table.
code
JSON
[
  { "id": "pioneer", "name_en": "Pioneer", "name_ar": "الرائد", "description_en": "Submitted your first report.", "description_ar": "قدم أول بلاغ لك.", "icon": "FaStar", "is_active": true, "criteria": { "type": "report_count", "value": 1 } },
  { "id": "waste_warrior", "name_en": "Waste Warrior", "name_ar": "محارب النفايات", "description_en": "Submitted 3 reports about waste.", "description_ar": "قدم 3 بلاغات عن النفايات.", "icon": "FaDumpster", "is_active": true, "criteria": { "type": "report_count", "value": 3, "category_filter": "waste_environment" } },
  { "id": "road_guardian", "name_en": "Road Guardian", "name_ar": "حارس الطريق", "description_en": "Submitted a report about roads.", "description_ar": "قدم بلاغاً عن الطرق.", "icon": "FaShieldHalved", "is_active": true, "criteria": { "type": "report_count", "value": 1, "category_filter": "infrastructure" } },
  { "id": "lightbringer", "name_en": "Lightbringer", "name_ar": "جالب النور", "description_en": "Submitted a report about lighting.", "description_ar": "قدم بلاغاً عن الإنارة.", "icon": "FaLightbulb", "is_active": true, "criteria": { "type": "report_count", "value": 1, "category_filter": "electricity_energy" } },
  { "id": "civic_scout", "name_en": "Civic Scout", "name_ar": "الكشاف المدني", "description_en": "Submitted a report in the \"Other\" category.", "description_ar": "قدم بلاغاً من فئة \"أخرى\".", "icon": "FaQuestion", "is_active": true, "criteria": { "type": "report_count", "value": 1, "category_filter": "other_unknown" } },
  { "id": "city_explorer", "name_en": "City Explorer", "name_ar": "مستكشف المدينة", "description_en": "Reported in 3 different areas.", "description_ar": "قدم بلاغات في 3 مناطق مختلفة.", "icon": "FaLocationArrow", "is_active": true, "criteria": { "type": "report_count", "value": 3 } },
  { "id": "good_samaritan", "name_en": "Good Samaritan", "name_ar": "فاعل خير", "description_en": "Confirmed your first report.", "description_ar": "أكدت أول بلاغ لك.", "icon": "FaHeart", "is_active": true, "criteria": { "type": "confirmation_count", "value": 1 } },
  { "id": "community_helper", "name_en": "Community Helper", "name_ar": "مساعد المجتمع", "description_en": "Confirmed 5 reports.", "description_ar": "أكدت 5 بلاغات.", "icon": "FaHandshakeAngle", "is_active": true, "criteria": { "type": "confirmation_count", "value": 5 } },
  { "id": "civic_leader", "name_en": "Civic Leader", "name_ar": "قائد مدني", "description_en": "Reached 100 points.", "description_ar": "وصلت إلى 100 نقطة.", "icon": "FaTrophy", "is_active": true, "criteria": { "type": "point_threshold", "value": 100 } },
  { "id": "water_watchdog", "name_en": "Water Watchdog", "name_ar": "رقيب المياه", "description_en": "Reported an issue about water or sanitation.", "description_ar": "قدم بلاغاً عن المياه أو الصرف الصحي.", "icon": "FaDroplet", "is_active": true, "criteria": { "type": "report_count", "value": 1, "category_filter": "water_sanitation" } },
  { "id": "safety_sentinel", "name_en": "Safety Sentinel", "name_ar": "حارس السلامة", "description_en": "Reported a public safety hazard.", "description_ar": "قدم بلاغاً عن خطر على السلامة العامة.", "icon": "FaTrafficLight", "is_active": true, "criteria": { "type": "report_count", "value": 1, "category_filter": "public_safety" } },
  { "id": "park_protector", "name_en": "Park Protector", "name_ar": "حامي الحدائق", "description_en": "Reported an issue in a public space.", "description_ar": "قدم بلاغاً عن مشكلة في مساحة عامة.", "icon": "FaPersonShelter", "is_active": true, "criteria": { "type": "report_count", "value": 1, "category_filter": "public_spaces" } },
  { "id": "health_hero", "name_en": "Health Hero", "name_ar": "بطل الصحة", "description_en": "Reported a public health concern.", "description_ar": "قدم بلاغاً عن مشكلة صحية عامة.", "icon": "FaVirusSlash", "is_active": true, "criteria": { "type": "report_count", "value": 1, "category_filter": "public_health" } },
  { "id": "urban_planner", "name_en": "Urban Planner", "name_ar": "المخطط الحضري", "description_en": "Reported an urban planning violation.", "description_ar": "قدم بلاغاً عن مخالفة تخطيط عمراني.", "icon": "FaBuildingUser", "is_active": true, "criteria": { "type": "report_count", "value": 1, "category_filter": "urban_planning" } }
]
Important Backend Implementation Details
Soft Deletes: Do not physically delete categories or badges (DELETE FROM categories WHERE...). If a category is attached to existing reports, physically deleting it will break the app. Instead, toggle the is_active flag to false. The frontend is built to filter out inactive categories for new reports but still display them for old reports.
Caching: Since categories and badges don't change often, you should cache the GET /api/categories and GET /api/badges responses (e.g., Redis or in-memory) and invalidate the cache only when the Super Admin makes a change.
Validation: When the Super Admin creates a badge with criteria.type = 'report_count', ensure category_filter is a valid Category ID that exists in your database.
Audit Logging: Every change the Super Admin makes (changing a point value, renaming a category) triggers an AuditLog entry. You must implement this logging on the backend side of these endpoints.
This data and logic is currently living in services/mockApi.ts and data/dynamicConfig.ts. You can refer to those files for the exact logic flow.

Super Admin Logic & Capabilities Specification
The Super Admin is the "God Mode" of the application. Unlike the Municipality Portal (which is scoped to specific regions), the Super Admin has unrestricted read/write access to all data tables.
1. Admin Account Management (RBAC System)
The Super Admin creates accounts for municipalities and utility companies. This relies on a Role-Based Access Control (RBAC) system stored in the User table.
Database Fields (User table)
You must implement these specific fields to handle permissions.
Field	Type	Description
role	enum	citizen, municipality, union_of_municipalities, utility, super_admin
municipality_id	string	Used only if role is municipality. Hard-links user to one area (e.g., 'beirut').
scoped_municipalities	string[]	Used if role is union or utility. Allows access to multiple areas (e.g., ['beirut', 'tripoli']).
scoped_categories	string[]	Used if role is utility. Limits access to specific categories (e.g., ['electricity_energy']).
portal_access_level	enum	read_write (can change status/comment) or read_only (view only).
Logic: Creating an Account (POST /api/users/admin)
When the Super Admin fills out the "Add New Account" form, the backend must validate the specific combination of fields based on the selected Role.
Municipality Role:
Input: username, password, municipality_id (e.g., 'beirut').
Backend Logic: Ensure municipality_id is unique. No two users can claim the same municipality (1-to-1 relationship).
Union of Municipalities Role:
Input: username, password, scoped_municipalities (Array).
Backend Logic: The user can see reports where report.municipality IN scoped_municipalities.
Utility / Public Institution Role:
Input: username, password, scoped_municipalities (Array), scoped_categories (Array).
Backend Logic: The user can only see reports where report.municipality IN scoped_municipalities AND report.category IN scoped_categories. (e.g., "Electricité Du Liban" only sees electricity reports).
2. Report Governance (Quality Control)
The Super Admin can edit or delete any report to fix data quality issues (e.g., a user selected the wrong location or category).
Logic: Editing a Report (PUT /api/reports/:id)
Capability: The Admin can update status, severity, category, sub_category, title, description, and lat/lng.
Audit: Every edit must generate a ReportHistory entry and an AuditLog entry.
Logic: Cascading Deletion (DELETE /api/reports/:id)
This is a hard delete or a deep soft delete. If the Super Admin deletes a report, the backend must ensure data integrity by removing/hiding all related child data.
Backend Transaction:
code
SQL
BEGIN TRANSACTION;
  DELETE FROM comments WHERE report_id = 'target_id';
  DELETE FROM report_history WHERE report_id = 'target_id';
  DELETE FROM notifications WHERE report_id = 'target_id';
  -- Update Users to remove references to this report
  UPDATE users SET subscribed_report_ids = array_remove(subscribed_report_ids, 'target_id');
  UPDATE users SET confirmed_report_ids = array_remove(confirmed_report_ids, 'target_id');
  -- Finally, delete the report
  DELETE FROM reports WHERE id = 'target_id';
COMMIT;
3. Citizen User Management
The Super Admin can manage the citizens using the app.
Logic: Suspension (PUT /api/users/:id)
Action: Admin toggles "Account Active" to false.
Backend Logic:
Set is_active = false in database.
Middleware Check: In your authentication middleware (verifyToken), check user.is_active. If false, immediately revoke the token or return 403 Account Suspended. The user should be logged out instantly on their next request.
Logic: Impersonation ("View As")
Goal: The Admin wants to see the app exactly as User X sees it (to debug issues).
Mechanism:
Frontend: Admin clicks "View as Nader".
Request: POST /api/users/:id/impersonate (Protected: Super Admin only).
Backend: Generates a short-lived JWT (e.g., 1 hour expiry) for User X.
Frontend:
Saves the Admin's token in sessionStorage (to restore later).
Replaces the App's main token with User X's token.
Reloads the app.
Exit: When clicking "Exit Impersonation", the frontend restores the Admin token from storage.
4. Audit Trail System
To ensure accountability, every "write" action performed by a Super Admin (or Portal Admin) must be logged.
Database Schema (AuditLog table)
code
TypeScript
interface AuditLog {
  id: string;
  timestamp: string;      // ISO Date
  actorId: string;        // User ID of the admin performing the action
  actorName: string;      // Cached display name (e.g., "Super Admin")
  actorRole: string;      // Cached role (e.g., "super_admin")
  message: string;        // Human readable string (e.g., "Deleted report #123")
}
Triggers
You must call logAuditEvent() in the controller for these endpoints:
User Mgmt: Create Admin, Update User, Suspend User.
Report Mgmt: Change Status, Edit Details, Delete Report.
Config: Update Categories, Update Badges, Update Gamification Rules.
5. Data Export (CSV)
The Super Admin (and Portal Admins) need to export data.
Logic: Export Reports
Filtering: The export must respect the current filters (Time range, Status, Category).
Format: CSV (Comma Separated Values).
Columns: ID, Title (EN/AR), Description, Category, Sub-Category, Severity, Status, Confirmations, Date, Municipality, Lat, Lng, Link to Image.
Backend: It is recommended to generate this stream on the backend to handle large datasets (e.g., 10k+ reports) without crashing the browser, though the current prototype does it client-side.
6. Default/Seed Accounts
When initializing your production database, you must seed these accounts so the Super Admin can log in immediately.
Super Admin (The "Owner"):
code
JSON
{
  "username": "miloadmin",
  "password": "hashed_password_here", // e.g., "okidoki11"
  "role": "super_admin",
  "display_name": "Super Admin",
  "is_active": true
}
Sample Municipality (For testing):
code
JSON
{
  "username": "beirut_admin",
  "password": "hashed_password_here",
  "role": "municipality",
  "municipality_id": "beirut",
  "display_name": "Beirut Municipality",
  "portal_access_level": "read_write"
}

1. Dashboard Analytics Engine (Aggregation)
The Problem: The current frontend (SuperAdminDashboardPage.tsx) calculates statistics by downloading every report and history entry and doing math in the browser.
Real Backend Requirement: In production, you cannot download 100,000 reports to the browser to count them. The backend must perform these aggregations via SQL queries and return lightweight JSON summaries.
New Endpoint: GET /api/admin/stats
Response Structure:
code
JSON
{
  "counts": {
    "totalUsers": 1250,
    "totalReports": 4500,
    "totalMunicipalities": 12
  },
  "performance": {
    "avgResolutionTimeHours": 48.5 // Calculated from (Resolved Time - Created Time)
  },
  "leaderboards": {
    "municipalityResolution": [
      { "name": "Beirut", "resolvedCount": 150, "totalCount": 200 },
      { "name": "Tripoli", "resolvedCount": 80, "totalCount": 120 }
    ]
  },
  "reportsByCategory": {
    "infrastructure": 500,
    "waste_environment": 300,
    // ...
  }
}
Backend Logic:
Avg Resolution Time: requires a SQL query joining the reports table with the report_history table where status = 'resolved'.
Caching: These stats should be cached (e.g., Redis) and refreshed every 10-60 minutes, as they are heavy to calculate.
2. "Submit on Behalf" Workflow (The Ghost Session)
The Feature: The sidebar has a "New Report" button (SuperAdminReportCreator.tsx). This allows the Super Admin to submit a report (e.g., taken from a phone call) without logging out.
The Mechanism (Frontend Implementation):
The app creates a temporary Anonymous User in memory.
It switches the AppContext to use this temporary user (simulating a guest session).
It launches the standard Citizen Report Wizard.
Upon submission, it restores the Super Admin session.
Backend Implication:
You do not need a special endpoint for this, BUT you need to ensure your POST /api/reports endpoint accepts requests where the created_by is a newly generated anonymous ID, even if the request originates from an IP address associated with an Admin.
Refinement: Ideally, add a field submitted_by_admin_id to the Report model. If the Super Admin uses this feature, the backend should log that User X (Admin) physically submitted the report on behalf of User Y (Anonymous) for audit purposes.
3. Granular Comment Moderation
The Feature: In SuperAdminReportDetailsPage.tsx, there is a trash icon next to every comment.
The Mechanism:
Endpoint: DELETE /api/comments/:id
Logic: This is a hard delete or a redacted soft delete.
Backend Logic:
Check if the requester is a Super Admin.
Delete the comment record.
Audit: Log User [AdminID] deleted comment [CommentID] from Report [ReportID].
Recalculate: If you rely on comment counts in other views, trigger a recount.
4. Manual User Point Adjustment
The Feature: In SuperAdminUsersPage.tsx -> "Edit User", there is a field to manually adjust a user's gamification points.
The Mechanism:
Context: Sometimes a user earns points unfairly, or you want to reward a specific offline action (e.g., "Volunteer of the Month").
Endpoint: PUT /api/users/:id
Payload: { "pointAdjustment": 50 } (Positive to add, negative to subtract).
Backend Logic:
Lock Row: Select the user row for update.
Math: new_points = current_points + payload.pointAdjustment.
Floor: Ensure points don't go below 0 (unless you allow debt).
Audit: This is crucial. You must log why the points were changed if possible, or at least that they were changed manually by an admin, so it doesn't look like a system glitch.
Summary of Database Schema Additions
To support the above, add these fields to your schema plan:
Report Model:
submitted_by_admin_id (String, Nullable): To track if an admin created a report on behalf of a citizen/guest.
AuditLog Model:
Ensure metadata (JSON) field exists to store specific details like "Adjusted points by +50".
Report History:
Ensure updated_by_id is strictly populated. When a Super Admin changes a status in the portal, their ID must be recorded here to distinguish between automatic system updates and manual admin overrides.

However, handing this to a backend engineer, there are three critical logical flows missing from the text that exist in the application but weren't explicitly detailed in your "Logic" sections.
Here are the missing pieces to make the spec 100% complete:
1. Notification Triggers (The "Feedback Loop")
In the Report Governance section, you mentioned deleting notifications, but you missed the logic for creating them when an Admin acts.
The Gap: If a Super Admin changes a report status from "New" to "In Progress", the user must know.
Add this to Logic: Editing a Report (PUT /api/reports/:id):
Backend Logic:
Fetch the existing report before saving changes.
Compare old_status vs new_status.
If status changed:
Fetch all subscribedUserIds for this report.
Create a Notification record for each subscriber.
Type: status_change.
Metadata: { oldStatus, newStatus, reportTitle }.
2. Admin-Initiated Password Resets
In Citizen User Management, you mentioned Suspension and Impersonation, but the Super Admin UI also has a "Set Password" feature for users (useful if a citizen gets locked out).
The Gap: The backend needs strict handling for this to avoid security holes.
Add this to Logic: Update User (PUT /api/users/:id):
Input: Optional new_password field.
Backend Logic:
If new_password is present in the payload:
Generate a new random salt.
Hash the new_password with the new salt (e.g., using Argon2 or bcrypt).
Update password_hash and salt in the database.
Never store the plain text password.
(Optional but recommended) Invalidate existing user sessions/tokens (logout the user).
3. Image/Media Handling Strategy
In Report Governance, you mentioned editing details, but handling the photo_urls array in a real backend is complex.
The Gap: The mock app uses Base64 strings. A real backend cannot store Base64 images in a SQL/NoSQL database column efficiently; it will crash the database performance.
Add this to General Backend Requirements:
Logic: When an Admin (or User) submits/edits a report with images:
The API should likely receive multipart/form-data OR a Base64 string.
The Backend must decode the image.
Upload the file to Object Storage (AWS S3, Google Cloud Storage, Azure Blob).
Get the public URL (e.g., https://s3.amazonaws.com/bucket/image.jpg).
Save only the URL string in the photo_urls array in the database.